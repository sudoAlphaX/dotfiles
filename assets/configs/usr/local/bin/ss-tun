#!/usr/bin/env sh

# Ensure the script is run as root
if [ "$(id -u)" -ne 0 ]; then
  echo "This script must be run as root." >&2
  exit 1
fi

if [ $# -ne 1 ] || ! test -f "$1"; then
  echo "Usage: sudo $0 <shadowocks_config_path>"
  exit 1
fi

SHADOWSOCKS_CONFIG_PATH="$1"
SHADOWSOCKS_CONFIG="$(cat "$SHADOWSOCKS_CONFIG_PATH")"
SS_USER="shadowsocks-tun" # Dedicated user for running sslocal to bypass the tunnel
FWMARK="10"               # A fwmark to identify packets from the sslocal process
ROUTING_TABLE="100"       # A separate routing table for the sslocal process

trap destroy EXIT HUP INT TERM

config() {
  key="$1"
  echo "$SHADOWSOCKS_CONFIG" | jq -r ".$key"
}

prepare() {
  echo "Preparing network environment"
  ip tuntap del name "$(config tun_interface_name)" mode tun 2>/dev/null || true
}

create() {
  prepare

  echo "Creating TUN interface"
  ip tuntap add name "$(config tun_interface_name)" mode tun user "$SS_USER"
  ip link set up dev "$(config tun_interface_name)"
  ip addr add "$(config tun_interface_address)" dev "$(config tun_interface_name)"

  # Get default route details
  defaults="$(ip -j route | jq '.[] | select(.dst=="default")')"
  default_iface="$(echo "$defaults" | jq -r .dev)"
  default_gateway="$(echo "$defaults" | jq -r .gateway)"

  echo "Setting up policy-based routing"

  # Mark packets from the sslocal user
  iptables -t mangle -A OUTPUT -m owner --uid-owner "$SS_USER" -j MARK --set-mark "$FWMARK"

  # Create a rule to use a separate routing table for marked packets
  ip rule add fwmark "$FWMARK" lookup "$ROUTING_TABLE"

  # Add a route to the separate table for the sslocal process
  # This ensures sslocal's own traffic can reach the server.
  ip route add default via "$default_gateway" dev "$default_iface" table "$ROUTING_TABLE"

  # Route all other traffic through the TUN device in the main table
  ip route add default dev "$(config tun_interface_name)" metric 50

  # Add other LAN subnets if needed.

  echo "Network setup complete. Default route is via TUN interface."
}

destroy() {
  echo "Cleaning up network configuration..."

  # Delete main default route via TUN interface
  ip route del default dev "$(config tun_interface_name)" 2>/dev/null || true

  # Delete the policy routing rule
  ip rule del fwmark "$FWMARK" lookup "$ROUTING_TABLE" 2>/dev/null || true

  # Delete the iptables marking rule
  # Check if rule exists before deleting to avoid errors on exit
  iptables -t mangle -C OUTPUT -m owner --uid-owner "$SS_USER" -j MARK --set-mark "$FWMARK" 2>/dev/null &&
    iptables -t mangle -D OUTPUT -m owner --uid-owner "$SS_USER" -j MARK --set-mark "$FWMARK"

  # Flush the custom routing table
  ip route flush table "$ROUTING_TABLE" 2>/dev/null || true

  # Clean up TUN interface
  ip link set down dev "$(config tun_interface_name)" 2>/dev/null || true
  ip tuntap del name "$(config tun_interface_name)" mode tun 2>/dev/null || true

  echo "Cleanup complete"
}

connect() {
  echo "Starting sslocal as user '$SS_USER'..."

  # Run sslocal as the dedicated user. All packets from this process will now be marked by iptables.

  sslocal \
    -s "$(config server):$(config server_port)" \
    -k "$(config password)" \
    -m "$(config method)" \
    --protocol tun \
    --tcp-fast-open \
    --tun-interface-name "$(config tun_interface_name)" \
    --tun-interface-address "$(config tun_interface_address)"
  # --dns google

}

main() {
  create
  connect
}

main
